#include "reflect_local.h"
#include "term.h"

#include "common/reflect.h"

#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int		g_primType;

char*	yyrfltext;
int		yyrfllineno;

static int			s_token = TOK_UNKNOWN;
static const char*	s_filename;

#define FOR_TOKEN(x) #x,
static const char* s_tokenNames[] =
{
	FORALL_TOKENS
	NULL
};
#undef FOR_TOKEN

#define MAX_IDENT_LEN 512

struct Attributes
{
	int		flags;
	char	elementCountVar[MAX_IDENT_LEN];
};

struct Variable
{
	struct Variable*	next;

	char				ident[MAX_IDENT_LEN];
	char				typeIdent[MAX_IDENT_LEN];
	enum PrimitiveType	primType;
	bool				prim;
	bool				array;
	char				elementCount[MAX_IDENT_LEN];

	struct Attributes	attribs;

	int					attribIndex;
};

struct Type
{
	struct Type*		next;

	char				ident[MAX_IDENT_LEN];
	struct Variable*	variables;
};

struct Type* s_types;

#define MEMORY_SIZE 100 * 4096

static struct
{
	char* cur;
	char* end;
} s_mem;

static void* Alloc(size_t size)
{
	void* ret = s_mem.cur;
	s_mem.cur += size;
	if(s_mem.cur > s_mem.end)
	{
		printf( TERM_RED( "Error: ") "Out of memory.\n" );
		exit(-1);
	}
	return ret;
}

static void StoreIdentifier(char* dst)
{
	if(strlen(yyrfltext) >= MAX_IDENT_LEN)
	{
		printf( TERM_RED( "Error: " ) "Identifier '%s' is too long.\n",
			yyrfltext );
		exit(-1);
	}
	strcpy(dst, yyrfltext);
}

static void PrintUsage(const char* exeName)
{
	printf("Usage: %s outfile infile ...\n", exeName);
}

static void WritePrelude(FILE* file)
{
	const char* prelude =
		"/* This file is automatically generated and any content will be overwritten. */\n"
		"\n"
		"#include \"../src/common/reflect.h\"\n"
		"#include \"../src/reflect/reflect_local.h\"\n"
		"\n"
		"#include <stddef.h>\n"
		"\n";

	fprintf(file, "%s", prelude);
}

static void WritePostlude(FILE* file)
{
	const char* postlude =
		"struct ReflectedType* g_types = s_types;\n"
		"struct ReflectedAttribute* g_attributes = s_attributes;";

	fprintf(file, "%s", postlude);
}

static void WriteIncludes(FILE* file, char** filenames, int count)
{
	int i;

	for(i = 0; i < count; ++i)
	{
		fprintf(file, "#include \"../%s\"\n", filenames[i]);
	}
}

static void WriteAttributes(FILE* file)
{
	const char* format =
		"\t{ "
		"%d, "									/* flags */
		"\"%s\", "								/* elementCountVar */
		" }, // %d\n";							/* index */

	fprintf(file, "static struct ReflectedAttribute s_attributes[] = {\n");

	int index = 0;

	struct Type* type = s_types;
	while(type)
	{
		struct Variable* var = type->variables;
		while(var)
		{
			if(var->attribs.flags)
			{
				struct Attributes* attribs = &var->attribs;
				fprintf(file, format,
					attribs->flags,
					attribs->elementCountVar,
					index);

				var->attribIndex = index++;
			}
			else
			{
				var->attribIndex = -1;
			}

			var = var->next;
		}

		type = type->next;
	}

	fprintf(file, "};\n");
}

static void WriteVariables(FILE* file)
{
	const char* format =
		"\t{ "
		"\"%s\", "								/* name */
		"\"%s\", "								/* typeName */
		"(int)sizeof(((struct %s*)0)->%s), "	/* size */
		"(int)offsetof(struct %s, %s), "		/* offset */
		"%d,"									/* primType */
		"%d,"									/* isPrim */
		"%d,"									/* isArray */
		"%s,"									/* elementCount */
		"%d"									/* attrib */
		" },\n";

	struct Type* type = s_types;
	while(type)
	{
		fprintf(file, "static struct ReflectedVariable s_variables_%s[] = {\n",
			type->ident);

		struct Variable* var = type->variables;
		while(var)
		{
			fprintf(file, format,
				var->ident,
				var->typeIdent,
				type->ident, var->ident,
				type->ident, var->ident,
				var->primType,
				var->prim,
				var->array,
				var->elementCount,
				var->attribIndex);

			var = var->next;
		}

		type = type->next;

		fprintf(file, "};\n");
	}
}

static void WriteTypes(FILE* file)
{
	const char* format =
		"\t{ "
		"\"%s\", "			/* name */
		"%d, "				/* variableCount */
		"s_variables_%s"	/* variables */
		" },\n";

	fprintf(file, "static struct ReflectedType s_types[] = {\n");

	struct Type* type = s_types;
	while(type)
	{
		int varCount = 0;
		struct Variable* var = type->variables;
		while(var)
		{
			varCount++;
			var = var->next;
		}

		fprintf(file, format,
			type->ident,
			varCount,
			type->ident);

		type = type->next;
	}

	/* Write sentinel */
	fprintf(file, "\t{0, 0, 0}\n");

	fprintf(file, "};\n");
}

int main(int argc, char* argv[])
{
	int i;

	if(argc < 3)
	{
		PrintUsage(argv[0]);
		return -1;
	}

	s_mem.cur = malloc(MEMORY_SIZE);
	s_mem.end = s_mem.cur + MEMORY_SIZE;
	memset(s_mem.cur, 0, MEMORY_SIZE);

	for(i = 2; i < argc; ++i)
	{
		printf( TERM_RED( "got file %s\n" ), argv[i]);
		Parse(argv[i]);
	}

	FILE* file = fopen(argv[1], "w");

	WritePrelude(file);

	WriteIncludes(file, argv + 2, argc - 2);

	fprintf(file, "\n");

	WriteAttributes(file);

	WriteVariables(file);

	fprintf(file, "\n");

	WriteTypes(file);

	fprintf(file, "\n");

	WritePostlude(file);

	fclose(file);

	return 0;
}

static void NextToken(void)
{
	s_token = yyrfllex();
}

static void ExpectToken(int tok)
{
	assert(tok >= 0 && tok < TOKEN_COUNT);
	if(tok != s_token)
	{
		printf( TERM_RED( "Error: " ) "%s:%d: Expected token '%s', but got '%s' instead.\n",
			s_filename, yyrfllineno, s_tokenNames[tok], yyrfltext );
		exit(-1);
	}
}

static void UnexpectedToken(void)
{
	printf( TERM_RED( "Error: " ) "%s:%d: Unexpected token '%s'.\n",
			s_filename, yyrfllineno, yyrfltext );
	exit(-1);
}

static void ParseVariableCommon(struct Variable* var)
{
	var->array = false;
	strcpy(var->elementCount, "0");
	
	StoreIdentifier(var->typeIdent);

	NextToken();
	ExpectToken(TOK_IDENT);

	StoreIdentifier(var->ident);

	NextToken();
	if(s_token == TOK_LBRACKET)
	{
		var->array = true;

		/* Parse array variable. */
		NextToken();

		if(s_token == TOK_INTEGER || s_token == TOK_IDENT)
		{
			StoreIdentifier(var->elementCount);
		}
		else
		{
			UnexpectedToken();
		}

		NextToken();
		ExpectToken(TOK_RBRACKET);

		NextToken();
	}

	ExpectToken(TOK_SEMICOL);
}

static void ParseAttribute(struct Variable* var)
{
	NextToken();

	ExpectToken(TOK_LPAREN);
	NextToken();

	ExpectToken(TOK_IDENT);
	if(!strcmp(yyrfltext, "elementCountVar"))
	{
		NextToken();
		ExpectToken(TOK_COLON);
		NextToken();
		ExpectToken(TOK_IDENT);

		StoreIdentifier(var->attribs.elementCountVar);
		var->attribs.flags |= AF_ELEMENT_COUNT_VAR;

		NextToken();
	}
	else
	{
		// TODO(cj): Common error function.
		printf( TERM_RED( "Error: " ) "%s:%d: Unknown attribute '%s'.\n",
				s_filename, yyrfllineno, yyrfltext );
		exit(-1);
	}

	ExpectToken(TOK_RPAREN);
}

static void ParsePrimitiveVariable(struct Variable* var)
{
	var->prim = true;
	var->primType = g_primType;

	ParseVariableCommon(var);
}

static void ParseStructVariable(struct Variable* var)
{
	var->prim = false;

	NextToken();
	ExpectToken(TOK_IDENT);
	
	ParseVariableCommon(var);
}

static void ParseType(void)
{
	bool done;

	NextToken();
	ExpectToken(TOK_STRUCT);

	NextToken();
	ExpectToken(TOK_IDENT);

	struct Type* type = Alloc(sizeof(struct Type));

	type->next = s_types;
	s_types = type;

	StoreIdentifier(type->ident);

	type->variables = NULL;

	NextToken();
	ExpectToken(TOK_LBRACE);

	struct Variable* var = Alloc(sizeof(struct Variable));

	done = false;
	while(!done)
	{
		NextToken();
		if(s_token == TOK_REFL_ATTRIB)
		{
			ParseAttribute(var);
		}
		else if(s_token == TOK_PRIM)
		{
			ParsePrimitiveVariable(var);

			var->next = type->variables;
			type->variables = var;

			var = Alloc(sizeof(struct Variable));
		}
		else if(s_token == TOK_STRUCT)
		{
			ParseStructVariable(var);

			var->next = type->variables;
			type->variables = var;

			var = Alloc(sizeof(struct Variable));
		}
		else if(s_token == TOK_RBRACE)
		{
			done = true;
		}
		else
		{
			UnexpectedToken();
		}
	}

	NextToken();
	ExpectToken(TOK_SEMICOL);

	/* Reverse variable order to make it the same as in source file. */
	var = type->variables;
	type->variables = NULL;
	while(var)
	{
		struct Variable* next = var->next;
		var->next = type->variables;
		type->variables = var;
		var = next;
	}
}

void StartParsing(const char* filename)
{
	bool done = false;

	s_filename = filename;

	while(!done)
	{
		NextToken();
		if(s_token == TOK_EOF)
		{
			done = true;
		}
		else if(s_token == TOK_REFLECTED)
		{
			ParseType();
		}
	}
}
