#include "reflect_local.h"
#include "term.h"

#include "common/reflect.h"

#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int		g_primType;

char*	yyrfltext;
int		yyrfllineno;

static int			s_token = TOK_UNKNOWN;
static const char*	s_filename;

#define FOR_TOKEN(x) #x,
static const char* s_tokenNames[] =
{
	FORALL_TOKENS
	NULL
};
#undef FOR_TOKEN

#define MAX_IDENT_LEN 512

struct Variable
{
	struct Variable*	next;

	char				ident[MAX_IDENT_LEN];
	char				typeIdent[MAX_IDENT_LEN];
	enum PrimitiveType	primType;
	bool				prim;
	bool				array;
	int					elementCount;
};

struct Type
{
	struct Type*		next;

	char				ident[MAX_IDENT_LEN];
	struct Variable*	variables;
};

struct Type* s_types;

#define MEMORY_SIZE 100 * 4096

static struct
{
	char* cur;
	char* end;
} s_mem;

static void* Alloc(size_t size)
{
	s_mem.cur += size;
	if(s_mem.cur > s_mem.end)
	{
		printf( TERM_RED( "Error: ") "Out of memory.\n" );
		exit(-1);
	}
	return s_mem.cur;
}

static void StoreIdentifier(char* dst)
{
	if(strlen(yyrfltext) >= MAX_IDENT_LEN)
	{
		printf( TERM_RED( "Error: " ) "Identifier '%s' is too long.\n",
			yyrfltext );
		exit(-1);
	}
	strcpy(dst, yyrfltext);
}

static void PrintUsage(const char* exeName)
{
	printf("Usage: %s outfile infile ...\n", exeName);
}

static void WritePrelude(FILE* file)
{
	const char* prelude =
		"/* This file is automatically generated and any content will be overwritten. */\n"
		"\n"
		"#include \"../src/common/reflect.h\"\n"
		"#include \"../src/reflect/reflect_local.h\"\n"
		"\n"
		"#include <stddef.h>\n"
		"\n";

	fprintf(file, "%s", prelude);
}

static void WritePostlude(FILE* file)
{
	const char* postlude =
		"struct ReflectedType* g_types = s_types;";

	fprintf(file, "%s", postlude);
}

static void WriteIncludes(FILE* file, char** filenames, int count)
{
	int i;

	for(i = 0; i < count; ++i)
	{
		fprintf(file, "#include \"../%s\"\n", filenames[i]);
	}
}

static void WriteVariables(FILE* file)
{
	const char* format =
		"\t{ "
		"\"%s\", "								/* name */
		"\"%s\", "								/* typeName */
		"(int)sizeof(((struct %s*)0)->%s), "	/* size */
		"(int)offsetof(struct %s, %s), "		/* offset */
		"%d,"									/* primType */
		"%d,"									/* isPrim */
		"%d,"									/* isArray */
		"%d"									/* elementCount */
		" },\n";

	struct Type* type = s_types;
	while(type)
	{
		fprintf(file, "static struct ReflectedVariable s_variables_%s[] = {\n",
			type->ident);

		struct Variable* var = type->variables;
		while(var)
		{
			fprintf(file, format,
				var->ident,
				var->typeIdent,
				type->ident, var->ident,
				type->ident, var->ident,
				var->primType,
				var->prim,
				var->array,
				var->elementCount);

			var = var->next;
		}

		type = type->next;

		fprintf(file, "};\n");
	}
}

static void WriteTypes(FILE* file)
{
	const char* format =
		"\t{ "
		"\"%s\", "			/* name */
		"%d, "				/* variableCount */
		"s_variables_%s"	/* variables */
		" },\n";

	fprintf(file, "static struct ReflectedType s_types[] = {\n");

	struct Type* type = s_types;
	while(type)
	{
		int varCount = 0;
		struct Variable* var = type->variables;
		while(var)
		{
			varCount++;
			var = var->next;
		}

		fprintf(file, format,
			type->ident,
			varCount,
			type->ident);

		type = type->next;
	}

	/* Write sentinel */
	fprintf(file, "\t{0, 0, 0}\n");

	fprintf(file, "};\n");
}

int main(int argc, char* argv[])
{
	int i;

	if(argc < 3)
	{
		PrintUsage(argv[0]);
		return -1;
	}

	s_mem.cur = malloc(MEMORY_SIZE);
	s_mem.end = s_mem.cur + MEMORY_SIZE;

	for(i = 2; i < argc; ++i)
	{
		printf( TERM_RED( "got file %s\n" ), argv[i]);
		Parse(argv[i]);
	}

	FILE* file = fopen(argv[1], "w");

	WritePrelude(file);

	WriteIncludes(file, argv + 2, argc - 2);

	fprintf(file, "\n");

	WriteVariables(file);

	fprintf(file, "\n");

	WriteTypes(file);

	fprintf(file, "\n");

	WritePostlude(file);

	fclose(file);

	return 0;
}

static void NextToken(void)
{
	s_token = yyrfllex();
}

static void ExpectToken(int tok)
{
	assert(tok >= 0 && tok < TOKEN_COUNT);
	if(tok != s_token)
	{
		printf( TERM_RED( "Error: " ) "%s:%d: Expected token '%s', but got '%s' instead.\n",
			s_filename, yyrfllineno, s_tokenNames[tok], yyrfltext );
		exit(-1);
	}
}

static void UnexpectedToken(void)
{
	printf( TERM_RED( "Error: " ) "%s:%d: Unexpected token '%s'.\n",
			s_filename, yyrfllineno, yyrfltext );
	exit(-1);
}

static void ParseVariableCommon(struct Type* type, struct Variable* var)
{
	var->array = false;
	var->elementCount = 0;
	
	StoreIdentifier(var->typeIdent);

	var->next = type->variables;
	type->variables = var;

	NextToken();
	ExpectToken(TOK_IDENT);

	StoreIdentifier(var->ident);

	NextToken();
	if(s_token == TOK_LBRACKET)
	{
		/* Parse array variable. */
		NextToken();
		ExpectToken(TOK_INTEGER);

		var->array = true;
		var->elementCount = atoi(yyrfltext);

		NextToken();
		ExpectToken(TOK_RBRACKET);

		NextToken();
	}

	ExpectToken(TOK_SEMICOL);
}

static void ParsePrimitiveVariable(struct Type* type)
{
	struct Variable* var = Alloc(sizeof(struct Variable));

	var->prim = true;
	var->primType = g_primType;

	ParseVariableCommon(type, var);
}

static void ParseStructVariable(struct Type* type)
{
	struct Variable* var = Alloc(sizeof(struct Variable));

	var->prim = false;

	NextToken();
	ExpectToken(TOK_IDENT);
	
	ParseVariableCommon(type, var);
}

static void ParseType(void)
{
	bool done;

	NextToken();
	ExpectToken(TOK_STRUCT);

	NextToken();
	ExpectToken(TOK_IDENT);

	struct Type* type = Alloc(sizeof(struct Type));

	type->next = s_types;
	s_types = type;

	StoreIdentifier(type->ident);

	type->variables = NULL;

	NextToken();
	ExpectToken(TOK_LBRACE);

	done = false;
	while(!done)
	{
		NextToken();
		if(s_token == TOK_PRIM)
		{
			ParsePrimitiveVariable(type);
		}
		else if(s_token == TOK_STRUCT)
		{
			ParseStructVariable(type);
		}
		else if(s_token == TOK_RBRACE)
		{
			done = true;
		}
		else
		{
			UnexpectedToken();
		}
	}

	NextToken();
	ExpectToken(TOK_SEMICOL);

	/* Reverse variable order to make it the same as in source file. */
	struct Variable* var = type->variables;
	type->variables = NULL;
	while(var)
	{
		struct Variable* next = var->next;
		var->next = type->variables;
		type->variables = var;
		var = next;
	}
}

void StartParsing(const char* filename)
{
	bool done = false;

	s_filename = filename;

	while(!done)
	{
		NextToken();
		if(s_token == TOK_EOF)
		{
			done = true;
		}
		else if(s_token == TOK_REFLECTED)
		{
			ParseType();
		}
	}
}
