#include "reflect_local.h"
#include "term.h"

#include "universal/reflect.h"

#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int		g_primType;

char*	yyrfltext;
int		yyrfllineno;

static int			s_token = TOK_UNKNOWN;
static const char*	s_filename;

#define FOR_TOKEN(x) #x,
static const char* s_tokenNames[] =
{
	FORALL_TOKENS
	NULL
};
#undef FOR_TOKEN

#define MAX_IDENT_LEN 512

struct Attributes
{
	int		flags;
	char	elementCountVar[MAX_IDENT_LEN];

	int		resolvedVar;
};

struct Variable
{
	char				ident[MAX_IDENT_LEN];
	char				typeIdent[MAX_IDENT_LEN];
	enum PrimitiveType	primType;
	bool				prim;
	bool				array;
	char				elementCount[MAX_IDENT_LEN];

	struct Attributes	attribs;

	int					attribIndex;
};

struct Type
{
	char				ident[MAX_IDENT_LEN];
	int					firstVariable;
	int					variableCount;
};

#define MEMORY_SIZE 100 * 4096

#define MAX_VARIABLES	4096
#define MAX_TYPES		512

static struct Variable		s_variables[MAX_VARIABLES];
static int					s_variableCount;

static struct Type			s_types[MAX_TYPES];
static int					s_typeCount;

static struct Attributes*	s_attributes[MAX_VARIABLES];
static int					s_attributeCount;

static struct
{
	char* cur;
	char* end;
} s_mem;

#if 0
static void* Alloc(size_t size)
{
	void* ret = s_mem.cur;
	s_mem.cur += size;
	if(s_mem.cur > s_mem.end)
	{
		printf( TERM_RED( "Error: ") "Out of memory.\n" );
		exit(-1);
	}
	return ret;
}
#endif

static void StoreIdentifier(char* dst)
{
	if(strlen(yyrfltext) >= MAX_IDENT_LEN)
	{
		printf( TERM_RED( "Error: " ) "Identifier '%s' is too long.\n",
			yyrfltext );
		exit(-1);
	}
	strcpy(dst, yyrfltext);
}

static void PrintUsage(const char* exeName)
{
	printf("Usage: %s outfile infile ...\n", exeName);
}

static void WritePrelude(FILE* file)
{
	const char* prelude =
		"/* This file is automatically generated and any content will be overwritten. */\n"
		"\n"
		"#include \"../src/universal/reflect.h\"\n"
		"#include \"../src/reflect/reflect_local.h\"\n"
		"\n"
		"#include <stddef.h>\n"
		"\n";

	fprintf(file, "%s", prelude);
}

static void WritePostlude(FILE* file)
{
	const char* postlude =
		"struct ReflectedType* g_types = s_types;\n"
		"struct ReflectedAttribute* g_attributes = s_attributes;\n"
		"struct ReflectedVariable* g_variables = s_variables;\n"
		"\n"
		"int g_attributeCount = %d;\n";

	fprintf(file, postlude,
		s_attributeCount);
}

static void WriteIncludes(FILE* file, char** filenames, int count)
{
	int i;

	for(i = 0; i < count; ++i)
	{
		fprintf(file, "#include \"../%s\"\n", filenames[i]);
	}
}

static void WriteAttributes(FILE* file)
{
	const char* format =
		"\t{ "
		"%d, "			/* flags */
		"%d "			/* elementCountVar */
		" }, // %d\n";	/* index */

	fprintf(file, "static struct ReflectedAttribute s_attributes[] = {\n");

	int index = 0;

	struct Type* type = s_types;
	struct Type* const typeEnd = s_types + s_typeCount;

	while(type != typeEnd)
	{
		struct Variable* var = s_variables + type->firstVariable;
		struct Variable* const varEnd = var + type->variableCount;

		while(var != varEnd)
		{
			if(var->attribs.flags)
			{
				struct Attributes* attribs = &var->attribs;
				fprintf(file, format,
					attribs->flags,
					attribs->resolvedVar,
					index);

				var->attribIndex = index++;
			}
			else
			{
				var->attribIndex = -1;
			}

			++var;
		}

		++type;
	}

	fprintf(file, "};\n");
}

static void WriteVariables(FILE* file)
{
	const char* format =
		"\t{ "
		"\"%s\", "								/* name */
		"\"%s\", "								/* typeName */
		"(int)sizeof(((struct %s*)0)->%s), "	/* size */
		"(int)offsetof(struct %s, %s), "		/* offset */
		"%d,"									/* primType */
		"%d,"									/* isPrim */
		"%d,"									/* isArray */
		"%s,"									/* elementCount */
		"%d"									/* attrib */
		" },\n";

	fprintf(file, "static struct ReflectedVariable s_variables[] = {\n");

	struct Type* type = s_types;
	struct Type* const typeEnd = s_types + s_typeCount;

	while(type != typeEnd)
	{
		struct Variable* var = s_variables + type->firstVariable;
		struct Variable* varEnd = var + type->variableCount;

		while(var != varEnd)
		{
			fprintf(file, format,
				var->ident,
				var->typeIdent,
				type->ident, var->ident,
				type->ident, var->ident,
				var->primType,
				var->prim,
				var->array,
				var->elementCount,
				var->attribIndex);

			++var;
		}

		++type;
	}

	fprintf(file, "};\n");
}

static void WriteTypes(FILE* file)
{
	const char* format =
		"\t{ "
		"\"%s\", "			/* name */
		"%d, "				/* variableCount */
		"s_variables + %d"	/* variables */
		" },\n";

	fprintf(file, "static struct ReflectedType s_types[] = {\n");

	struct Type* type = s_types;
	struct Type* const typeEnd = s_types + s_typeCount;

	while(type != typeEnd)
	{
		fprintf(file, format,
			type->ident,
			type->variableCount,
			type->firstVariable);

		++type;
	}

	/* Write sentinel */
	fprintf(file, "\t{0, 0, 0}\n");

	fprintf(file, "};\n");
}

static struct Variable* FindVariableByName(struct Type* type, const char* name)
{
	struct Variable* var = s_variables + type->firstVariable;
	struct Variable* varEnd = var + type->variableCount;

	while(var != varEnd)
	{
		if(!strcmp(var->ident, name))
		{
			return var;
		}
		++var;
	}

	return NULL;
}

static void ResolveAttributes(void)
{
	struct Type* type = s_types;
	struct Type* const typeEnd = s_types + s_typeCount;

	while(type != typeEnd)
	{
		struct Variable* var = s_variables + type->firstVariable;
		struct Variable* varEnd = var + type->variableCount;

		while(var != varEnd)
		{
			struct Attributes* attrib = &var->attribs;
			if(attrib->flags)
			{
				var->attribIndex = s_attributeCount;
				s_attributes[s_attributeCount++] = attrib;

				if(attrib->flags & AF_ELEMENT_COUNT_VAR)
				{
					struct Variable* countVar = FindVariableByName(type, attrib->elementCountVar);
					if(!countVar)
					{
						// TODO(cj): Common error function.
						printf( TERM_RED( "Error: " ) "%s:%d: Cannot resolve element count variable %s->%s.\n",
								s_filename, yyrfllineno, type->ident, attrib->elementCountVar );
						exit(-1);
					}

					bool validCountVar =
						countVar->prim &&
						!countVar->array &&
						(countVar->primType == PT_INT || countVar->primType == PT_UINT16 || countVar->primType == PT_INT);

					if(!validCountVar)
					{
						// TODO(cj): Common error function.
						printf( TERM_RED( "Error: " ) "%s:%d: Element count variable %s->%s has invalid type.\n",
								s_filename, yyrfllineno, type->ident, attrib->elementCountVar );
						exit(-1);
					}

					int variableIndex = (int)(countVar - s_variables);
					attrib->resolvedVar = variableIndex;
				}
			}

			++var;
		}

		++type;
	}
}

int main(int argc, char* argv[])
{
	int i;

	if(argc < 3)
	{
		PrintUsage(argv[0]);
		return -1;
	}

	s_mem.cur = malloc(MEMORY_SIZE);
	s_mem.end = s_mem.cur + MEMORY_SIZE;
	memset(s_mem.cur, 0, MEMORY_SIZE);

	for(i = 2; i < argc; ++i)
	{
		printf( TERM_RED( "got file %s\n" ), argv[i]);
		Parse(argv[i]);
	}

	ResolveAttributes();

	FILE* file = fopen(argv[1], "w");

	WritePrelude(file);

	WriteIncludes(file, argv + 2, argc - 2);

	fprintf(file, "\n");

	WriteAttributes(file);

	WriteVariables(file);

	fprintf(file, "\n");

	WriteTypes(file);

	fprintf(file, "\n");

	WritePostlude(file);

	fclose(file);

	return 0;
}

static void NextToken(void)
{
	s_token = yyrfllex();
}

static void ExpectToken(int tok)
{
	assert(tok >= 0 && tok < TOKEN_COUNT);
	if(tok != s_token)
	{
		printf( TERM_RED( "Error: " ) "%s:%d: Expected token '%s', but got '%s' instead.\n",
			s_filename, yyrfllineno, s_tokenNames[tok], yyrfltext );
		exit(-1);
	}
}

static void UnexpectedToken(void)
{
	printf( TERM_RED( "Error: " ) "%s:%d: Unexpected token '%s'.\n",
			s_filename, yyrfllineno, yyrfltext );
	exit(-1);
}

static void ParseVariableCommon(struct Variable* var)
{
	var->array = false;
	strcpy(var->elementCount, "0");
	
	StoreIdentifier(var->typeIdent);

	NextToken();
	ExpectToken(TOK_IDENT);

	StoreIdentifier(var->ident);

	NextToken();
	if(s_token == TOK_LBRACKET)
	{
		var->array = true;

		/* Parse array variable. */
		NextToken();

		if(s_token == TOK_INTEGER || s_token == TOK_IDENT)
		{
			StoreIdentifier(var->elementCount);
		}
		else
		{
			UnexpectedToken();
		}

		NextToken();
		ExpectToken(TOK_RBRACKET);

		NextToken();
	}

	ExpectToken(TOK_SEMICOL);
}

static void ParseAttribute(struct Variable* var)
{
	NextToken();

	ExpectToken(TOK_LPAREN);
	NextToken();

	ExpectToken(TOK_IDENT);
	if(!strcmp(yyrfltext, "elementCountVar"))
	{
		NextToken();
		ExpectToken(TOK_COLON);
		NextToken();
		ExpectToken(TOK_IDENT);

		StoreIdentifier(var->attribs.elementCountVar);
		var->attribs.flags |= AF_ELEMENT_COUNT_VAR;

		NextToken();
	}
	else
	{
		// TODO(cj): Common error function.
		printf( TERM_RED( "Error: " ) "%s:%d: Unknown attribute '%s'.\n",
				s_filename, yyrfllineno, yyrfltext );
		exit(-1);
	}

	ExpectToken(TOK_RPAREN);
}

static void ParsePrimitiveVariable(struct Variable* var)
{
	var->prim = true;
	var->primType = g_primType;

	ParseVariableCommon(var);
}

static void ParseStructVariable(struct Variable* var)
{
	var->prim = false;

	NextToken();
	ExpectToken(TOK_IDENT);
	
	ParseVariableCommon(var);
}

static struct Type* CreateType(void)
{
	if(s_typeCount + 1 >= MAX_TYPES)
	{
		printf( TERM_RED( "Error: ") "Cannot create type.\n" );
		exit(-1);
	}
	return s_types + s_typeCount++;
}

static struct Variable* CreateVariable(void)
{
	if(s_variableCount + 1 >= MAX_VARIABLES)
	{
		printf( TERM_RED( "Error: ") "Cannot create variable.\n" );
		exit(-1);
	}
	return s_variables + s_variableCount++;
}

static void ParseType(void)
{
	bool done;

	NextToken();
	ExpectToken(TOK_STRUCT);

	NextToken();
	ExpectToken(TOK_IDENT);

	struct Type* type = CreateType();

	StoreIdentifier(type->ident);

	type->firstVariable = s_variableCount;
	type->variableCount = 0;

	NextToken();
	ExpectToken(TOK_LBRACE);

	struct Variable* var = NULL;

	done = false;
	while(!done)
	{
		NextToken();
		if(s_token == TOK_REFL_ATTRIB)
		{
			if(!var)
			{
				var = CreateVariable();
			}

			ParseAttribute(var);
		}
		else if(s_token == TOK_PRIM)
		{
			if(!var)
			{
				var = CreateVariable();
			}

			ParsePrimitiveVariable(var);

			++type->variableCount;
			var = NULL;
		}
		else if(s_token == TOK_STRUCT)
		{
			if(!var)
			{
				var = CreateVariable();
			}

			ParseStructVariable(var);

			++type->variableCount;
			var = NULL;
		}
		else if(s_token == TOK_RBRACE)
		{
			done = true;
		}
		else
		{
			UnexpectedToken();
		}
	}

	NextToken();
	ExpectToken(TOK_SEMICOL);
}

void StartParsing(const char* filename)
{
	bool done = false;

	s_filename = filename;

	while(!done)
	{
		NextToken();
		if(s_token == TOK_EOF)
		{
			done = true;
		}
		else if(s_token == TOK_REFLECTED)
		{
			ParseType();
		}
	}
}
